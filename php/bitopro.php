<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class bitopro extends Exchange {

    public function describe () {
        $result = array_replace_recursive (parent::describe (), array (
            'id' => 'bitopro',
            'name' => 'BitoPro',
            'countries' => array ( 'TW' ),
            'version' => 'v3',
            'rateLimit' => 1000,
            'has' => array (
                'CORS' => false,
                'fetchStatus' => false,
                'fetchCurrencies' => true,
                'fetchOrderBook' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchOHLCV' => true,
                'fetchBalance' => true,
                'fetchOrders' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'fetchMyTrades' => true,
                'createOrder' => true,
                'cancelOrder' => true,
                'fetchOrder' => true,
            ),
            'timeframes' => array (
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '3h' => '3h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array (
                'logo' => 'https://www.bitopro.com/bitoPro_logo.svg',
                'api' => 'https://api.bitopro.com/v3',
                'www' => 'https://www.bitopro.com',
                'doc' => array (
                    'https://developers.bitopro.com',
                ),
                'fees' => 'https://www.bitopro.com/fees',
                'referral' => 'https://www.bitopro.com/landing_pages/reward',
            ),
            'api' => array (
                'public' => array (
                    'get' => array (
                        'order-book/{pair}',
                        'tickers',
                        'tickers/{pair}',
                        'trades/{pair}',
                        'provisioning/trading-pairs',
                        'trading-history/{pair}',
                    ),
                ),
                'private' => array (
                    'get' => array (
                        'accounts/balance',
                        'orders/history',
                        'orders/{pair}',
                        'orders/{pair}/{orderId}',
                    ),
                    'post' => array (
                        'orders/{pair}',
                    ),
                    'delete' => array (
                        'orders/{pair}/{id}',
                    ),
                ),
            ),
        ));
        return $result;
    }

    public function parse_ohlcv ($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        return array (
            $this->safe_integer($ohlcv, 'timestamp'),
            $this->safe_float($ohlcv, 'open'),
            $this->safe_float($ohlcv, 'high'),
            $this->safe_float($ohlcv, 'low'),
            $this->safe_float($ohlcv, 'close'),
            $this->safe_float($ohlcv, 'volume'),
        );
    }

    public function fetch_ohlcv ($symbol, $timeframe = '5m', $since = null, $limit = 500, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $nonce = intval ($this->nonce () / 1000);
        $fromTimstamp = ($nonce - 86400);
        if ($since !== null) {
            $fromTimstamp = intval ($since / 1000);
        }
        $toTimstamp = $nonce;
        $to = $this->safe_value($params, 'to');
        if ($to) {
            $toTimstamp = intval ($to / 1000);
        }
        $resolution = $this->timeframes[$timeframe];
        $request = array (
            'pair' => $market['id'],
            'resolution' => $resolution,
            'from' => $fromTimstamp,
            'to' => $toTimstamp,
        );
        $response = $this->publicGetTradingHistoryPair (array_merge ($request, $params));
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function fetch_currencies ($params = array ()) {
        $response = $this->fetch_tickers();
        $keys = is_array($response) ? array_keys($response) : array();
        $symbolLength = is_array ($keys) ? count ($keys) : 0;
        $result = array();
        for ($c = 0; $c < $symbolLength; $c++) {
            $pair = $keys[$c];
            $currency = $response[$pair];
            $symbols = explode('/', $pair);
            $symbolLength = is_array ($symbols) ? count ($symbols) : 0;
            for ($i = 0; $i < $symbolLength; $i++) {
                $symbol = $symbols[$i];
                $id = $symbol;
                $name = $symbol;
                $code = $this->common_currency_code($symbol);
                $result[$code] = array (
                    'id' => $id,
                    'code' => $code,
                    'info' => $currency,
                    'name' => $name,
                    'active' => true,
                    'fee' => null,
                    'precision' => null,
                    'limits' => array (
                        'amount' => array (
                            'min' => null,
                            'max' => null,
                        ),
                        'price' => array (
                            'min' => null,
                            'max' => null,
                        ),
                        'cost' => array (
                            'min' => null,
                            'max' => null,
                        ),
                        'withdraw' => array (
                            'min' => null,
                            'max' => null,
                        ),
                    ),
                );
            }
        }
        return $result;
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->publicGetProvisioningTradingPairs ();
        $markets = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count ($markets); $i++) {
            $market = $markets[$i];
            $active = !$market['maintain'];
            $pair = $this->safe_string($market, 'pair');
            $base = $this->safe_string($market, 'base');
            $quote = $this->safe_string($market, 'quote');
            $id = $pair;
            $base = $this->common_currency_code($base);
            $base = strtoupper($base);
            $quote = $this->common_currency_code($quote);
            $quote = strtoupper($quote);
            $symbol = $base . '/' . $quote;
            $precision = array (
                'price' => $this->safe_integer($market, 'quotePrecision'),
                'amount' => $this->safe_integer($market, 'basePrecision'),
                'cost' => null,
            );
            $limits = array (
                'amount' => array (
                    'min' => $this->safe_float($market, 'minLimitBaseAmount'),
                    'max' => $this->safe_float($market, 'maxLimitBaseAmount'),
                ),
                'price' => array (
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array (
                    'min' => null,
                    'max' => null,
                ),
            );
            $result[] = array (
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $base,
                'quoteId' => $quote,
                'limits' => $limits,
                'precision' => $precision,
                'active' => $active,
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_balance ($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetAccountsBalance ($params);
        $balances = $this->safe_value($response, 'data', array());
        $result = array (
            'info' => $balances,
        );
        for ($i = 0; $i < count ($balances); $i++) {
            $balance = $balances[$i];
            $currencyId = $this->safe_string($balance, 'currency');
            $currencyId = strtoupper($currencyId);
            $amount = $this->safe_float($balance, 'amount');
            $available = $this->safe_float($balance, 'available');
            $stake = $this->safe_float($balance, 'stake');
            $account = array (
                'free' => $available,
                'stake' => $stake,
                'used' => $amount - $available - $stake,
                'total' => $amount,
            );
            $result[$currencyId] = $account;
        }
        return $this->parse_balance($result);
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $timestamp = $this->milliseconds ();
        $this->load_markets();
        $request = array (
            'pair' => $this->market_id($symbol),
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        } else {
            $limit = 5;
            $request['limit'] = $limit;
        }
        $response = $this->publicGetOrderBookPair (array_merge ($request, $params));
        return $this->parse_order_book($response, $timestamp, 'bids', 'asks', 'price', 'amount');
    }

    public function parse_ticker ($ticker, $market = null) {
        $timestamp = $this->milliseconds ();
        $pair = $this->safe_string($ticker, 'pair');
        $pair = strtoupper($pair);
        list($base, $quote) = explode('_', $pair);
        $base = $this->common_currency_code($base);
        $quote = $this->common_currency_code($quote);
        $symbol = $base . '/' . $quote;
        return array (
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($ticker, 'high24hr'),
            'low' => $this->safe_float($ticker, 'low24hr'),
            'bid' => null,
            'bidVolume' => null,
            'ask' => null,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $this->safe_float($ticker, 'lastPrice'),
            'last' => $this->safe_float($ticker, 'lastPrice'),
            'previousClose' => null,
            'change' => null,
            'percentage' => $this->safe_float($ticker, 'priceChange24hr'),
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'volume24hr'),
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function fetch_tickers ($symbols = null, $params = array ()) {
        $response = $this->publicGetTickers ();
        $tickers = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count ($tickers); $i++) {
            $ticker = $this->parse_ticker($tickers[$i]);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $result;
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        $market = $this->market ($symbol);
        $request = array (
            'pair' => $market['id'],
        );
        $response = $this->publicGetTickersPair (array_merge ($request, $params));
        $ticker = $this->safe_value($response, 'data', array());
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_trade ($trade, $market) {
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'amount');
        $timestampSeconds = $this->safe_value($trade, 'timestamp');
        $timestamp = $timestampSeconds * 1000;
        $side = ($trade['isBuyer']) ? 'buy' : 'sell';
        return array (
            'info' => $trade,
            'id' => null,
            'order' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $market['symbol'],
            'takerOrMaker' => null,
            'type' => null,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        );
    }

    public function fetch_trades ($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array (
            'pair' => $market['id'],
        );
        $response = $this->publicGetTradesPair (array_merge ($request, $params));
        $trades = $this->safe_value($response, 'data', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function parse_order_execution ($order) {
        $orderId = $this->safe_string($order, 'orderId');
        return array (
            'id' => $orderId,
            'info' => $order,
        );
    }

    public function create_order ($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired('createOrder requires the $symbol parameter');
        }
        $request = array (
            'type' => strtoupper($type),
            'pair' => $this->market_id($symbol),
            'action' => strtoupper($side),
            'amount' => $amount,
            'timestamp' => $this->nonce (),
        );
        if (strtolower($type) === 'limit') {
            $request['price'] = $price;
        }
        $response = $this->privatePostOrdersPair (array_merge ($request, $params), $params);
        return $this->parse_order_execution ($response);
    }

    public function cancel_order ($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired('cancelOrder requires the $symbol parameter');
        }
        $request = array (
            'pair' => $this->market_id($symbol),
            'id' => $id,
        );
        $response = $this->privateDeleteOrdersPairId (array_merge ($request, $params));
        return $this->parse_order_execution ($response);
    }

    public function parse_order_status ($status) {
        $statuses = array (
            '0' => 'open',
            '1' => 'open',
            '2' => 'closed',
            '3' => 'closed',
            '4' => 'canceled',
        );
        return $this->safe_string($statuses, $status, null);
    }

    public function parse_order ($order, $market = null) {
        $orderId = $this->safe_string($order, 'id');
        $timestamp = $this->safe_integer($order, 'timestamp');
        $marketId = $this->safe_string($order, 'pair');
        $market = $this->safe_value($this->markets_by_id, $marketId);
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $symbol = $this->safe_string($market, 'symbol');
        $type = strtolower($this->safe_string($order, 'type'));
        $side = strtolower($this->safe_string($order, 'action'));
        $price = $this->safe_float($order, 'price');
        $amount = $this->safe_float($order, 'originalAmount');
        $filled = $this->safe_float($order, 'executedAmount');
        $remaining = $this->safe_float($order, 'remainingAmount');
        $fee = $this->safe_float($order, 'fee');
        $feeSymbol = $this->safe_string($order, 'feeSymbol');
        $feeSymbol = strtoupper($feeSymbol);
        return array (
            'id' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'lastTradeTimestamp' => null,
            'type' => $type,
            'status' => $status,
            'symbol' => $symbol,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'cost' => null,
            'remaining' => $remaining,
            'average' => null,
            'trades' => null,
            'fee' => array (
                'currency' => $feeSymbol,
                'cost' => $fee,
            ),
            'info' => $order,
        );
    }

    public function fetch_order ($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array (
            'orderId' => $id,
            'pair' => $this->market_id($symbol),
        );
        $response = $this->privateGetOrdersPairOrderId (array_merge ($request, $params));
        return $this->parse_order($response);
    }

    public function fetch_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market ($symbol);
            $request['pair'] = $market['id'];
        }
        $response = $this->privateGetOrdersPair (array_merge ($request, $params), $params);
        $orders = $this->safe_value($response, 'data', array());
        $orderLength = is_array ($orders) ? count ($orders) : 0;
        $result = array();
        for ($i = 0; $i < $orderLength; $i++) {
            $order = $orders[$i];
            $parsedOrder = $this->parse_order($order);
            $result[] = $parsedOrder;
        }
        return $result;
    }

    public function fetch_open_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array (
            'active' => true,
        );
        return $this->fetch_orders($symbol, $since, $limit, array_merge ($request, $params));
    }

    public function fetch_closed_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array (
            'active' => false,
        );
        $orders = $this->fetch_orders($symbol, $since, $limit, array_merge ($request, $params));
        $result = array();
        $orderLength = is_array ($orders) ? count ($orders) : 0;
        for ($i = 0; $i < $orderLength; $i++) {
            $order = $orders[$i];
            $status = $this->safe_string($order, 'status');
            if ($status === 'closed' || $status === 'canceled') {
                $result[] = $order;
            }
        }
        return $result;
    }

    public function parse_my_trade ($myTrade) {
        $orderId = $this->safe_string($myTrade, 'id');
        $timestamp = $this->safe_integer($myTrade, 'timestamp');
        $marketId = $this->safe_string($myTrade, 'pair');
        $market = $this->safe_value($this->markets_by_id, $marketId);
        $symbol = $this->safe_string($market, 'symbol');
        $type = strtolower($this->safe_string($myTrade, 'type'));
        $side = strtolower($this->safe_string($myTrade, 'action'));
        $price = $this->safe_float($myTrade, 'price');
        $filled = $this->safe_float($myTrade, 'executedAmount');
        $fee = $this->safe_float($myTrade, 'fee');
        $feeSymbol = $this->safe_string($myTrade, 'feeSymbol');
        $feeSymbol = strtoupper($feeSymbol);
        return array (
            'info' => $myTrade,
            'id' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $filled,
            'cost' => null,
            'fee' => array (
                'cost' => $fee,
                'currency' => $feeSymbol,
                'rate' => null,
            ),
        );
    }

    public function fetch_my_trades ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array (
            'pair' => $market['id'],
        );
        $response = $this->privateGetOrdersHistory (array_merge ($request, $params));
        $trades = $this->safe_value($response, 'data', array());
        $tradesLength = is_array ($trades) ? count ($trades) : 0;
        $result = array();
        for ($i = 0; $i < $tradesLength; $i++) {
            $trade = $trades[$i];
            $executedAmount = $this->safe_float($trade, 'executedAmount');
            if ($executedAmount > 0 && $trade['pair'] === $market['id']) {
                $myTrade = $this->parse_my_trade ($trade);
                $result[] = $myTrade;
            }
        }
        return $result;
    }

    public function nonce () {
        return $this->milliseconds ();
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '/' . $this->implode_params($path, $params);
        $query = $this->omit ($params, $this->extract_params($path));
        if ($headers === null) {
            $headers = array();
        }
        $headers['X-BITOPRO-API'] = 'ccxt';
        if ($api === 'private') {
            $this->check_required_credentials();
            if ($method === 'POST') {
                $body = $this->json ($params);
                $payload = base64_encode ($body);
                $signature = $this->hmac ($payload, $this->secret, 'sha384', 'hex');
                $headers['X-BITOPRO-APIKEY'] = $this->apiKey;
                $headers['X-BITOPRO-PAYLOAD'] = $payload;
                $headers['X-BITOPRO-SIGNATURE'] = $signature;
            } else if ($method === 'GET' || $method === 'DELETE') {
                if ($query) {
                    $url .= '?' . $this->urlencode ($query);
                }
                $nonce = $this->nonce ();
                $rawData = array (
                    'identity' => $this->email,
                    'nonce' => $nonce,
                );
                $rawData = $this->json ($rawData);
                $payload = base64_encode ($rawData);
                $signature = $this->hmac ($payload, $this->secret, 'sha384', 'hex');
                $headers['X-BITOPRO-APIKEY'] = $this->apiKey;
                $headers['X-BITOPRO-PAYLOAD'] = $payload;
                $headers['X-BITOPRO-SIGNATURE'] = $signature;
            }
        } else if ($api === 'public' && $method === 'GET') {
            if ($query) {
                $url .= '?' . $this->urlencode ($query);
            }
        }
        $url = $this->urls['api'] . $url;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors ($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($code >= 200 && $code < 300) {
            return;
        }
        if ($code === 401) {
            throw new AuthenticationError($body);
        }
        if ($code === 429) {
            throw new DDoSProtection($body);
        }
        $feedback = $body;
        throw new ExchangeError($feedback);
    }
}
